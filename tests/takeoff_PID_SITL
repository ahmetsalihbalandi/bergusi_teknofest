from dronekit import connect, VehicleMode
from pymavlink import mavutil  # Needed for command message definitions
import time
import math

# Set up option parsing to get connection string
import argparse
parser = argparse.ArgumentParser(description='Control Copter and send commands in GUIDED_NOGPS mode ')
parser.add_argument('--connect',
                    default='/dev/ttyAMA0',  # Default port set to AMA0
                    help="Vehicle connection target string. If not specified, default is AMA0.")
args = parser.parse_args()

connection_string = args.connect

# Connect to the Vehicle via AMA0 port
print('Connecting to vehicle on: %s' % connection_string)
vehicle = connect(connection_string, baud=57600, wait_ready=True)  # Ensure correct baud rate

# PID Controller Class
class PIDController:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.prev_error = 0
        self.integral = 0

    def update(self, error, dt):
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt if dt > 0 else 0
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output

# Set up PID controllers for pitch, roll, and altitude (thrust)
pid_pitch = PIDController(Kp=0.1, Ki=0.01, Kd=0.01)
pid_roll = PIDController(Kp=0.1, Ki=0.01, Kd=0.01)
pid_thrust = PIDController(Kp=0.1, Ki=0.01, Kd=0.01)

def arm_and_takeoff_nogps(aTargetAltitude):
    """
    Arms vehicle and fly to aTargetAltitude without GPS data.
    """

    ##### CONSTANTS #####
    DEFAULT_TAKEOFF_THRUST = 0.7
    SMOOTH_TAKEOFF_THRUST = 0.6

    print("Basic pre-arm checks")
    while not vehicle.is_armable:
        print(" Waiting for vehicle to initialise...")
        time.sleep(1)

    print("Arming motors")
    vehicle.mode = VehicleMode("GUIDED_NOGPS")
    vehicle.armed = True

    while not vehicle.armed:
        print(" Waiting for arming...")
        time.sleep(1)

    print("Taking off!")

    thrust = DEFAULT_TAKEOFF_THRUST
    while True:
        current_altitude = vehicle.location.global_relative_frame.alt
        print(" Altitude: %f  Desired: %f" % (current_altitude, aTargetAltitude))
        if current_altitude >= aTargetAltitude * 0.95:
            print("Reached target altitude")
            break
        elif current_altitude >= aTargetAltitude * 0.6:
            thrust = SMOOTH_TAKEOFF_THRUST
        set_attitude(thrust=thrust)
        time.sleep(0.2)

def send_attitude_target(roll_angle=0.0, pitch_angle=0.0,
                         yaw_angle=None, yaw_rate=0.0, use_yaw_rate=False,
                         thrust=0.5):
    if yaw_angle is None:
        yaw_angle = vehicle.attitude.yaw

    msg = vehicle.message_factory.set_attitude_target_encode(
        0, 1, 1,
        0b00000000 if use_yaw_rate else 0b00000100,
        to_quaternion(roll_angle, pitch_angle, yaw_angle),
        0, 0,
        math.radians(yaw_rate),
        thrust
    )
    vehicle.send_mavlink(msg)

def set_attitude(roll_angle=0.0, pitch_angle=0.0,
                 yaw_angle=None, yaw_rate=0.0, use_yaw_rate=False,
                 thrust=0.5, duration=0):
    send_attitude_target(roll_angle, pitch_angle,
                         yaw_angle, yaw_rate, False,
                         thrust)
    start = time.time()
    while time.time() - start < duration:
        send_attitude_target(roll_angle, pitch_angle,
                             yaw_angle, yaw_rate, False,
                             thrust)
        time.sleep(0.1)
    send_attitude_target(0, 0, 0, 0, True, thrust)

def to_quaternion(roll=0.0, pitch=0.0, yaw=0.0):
    t0 = math.cos(math.radians(yaw * 0.5))
    t1 = math.sin(math.radians(yaw * 0.5))
    t2 = math.cos(math.radians(roll * 0.5))
    t3 = math.sin(math.radians(roll * 0.5))
    t4 = math.cos(math.radians(pitch * 0.5))
    t5 = math.sin(math.radians(pitch * 0.5))

    w = t0 * t2 * t4 + t1 * t3 * t5
    x = t0 * t3 * t4 - t1 * t2 * t5
    y = t0 * t2 * t5 + t1 * t3 * t4
    z = t1 * t2 * t4 - t0 * t3 * t5

    return [w, x, y, z]

def stabilize_position(target_x, target_y, target_altitude):
    """
    Controls the drone based on IMU, barometer and optical flow sensor to stabilize its position.
    """
    current_x, current_y = 0, 0
    last_time = time.time()
    while True:
        # Read sensor data
        flow_x, flow_y = get_optical_flow_data()  # Custom function for reading optical flow
        imu_roll, imu_pitch = vehicle.attitude.roll, vehicle.attitude.pitch  # IMU data for roll and pitch
        baro_alt = vehicle.location.global_relative_frame.alt  # Barometer altitude

        # Update current x, y based on flow data
        current_x += flow_x
        current_y += flow_y

        print(f"Current X: {current_x}, Y: {current_y}, Altitude: {baro_alt}")

        # Calculate errors
        error_x = target_x - current_x
        error_y = target_y - current_y
        error_altitude = target_altitude - baro_alt

        # PID update
        current_time = time.time()
        dt = current_time - last_time
        last_time = current_time

        roll_output = pid_roll.update(error_x, dt)
        pitch_output = pid_pitch.update(error_y, dt)
        thrust_output = 0.5 + pid_thrust.update(error_altitude, dt)

        # Set attitude to correct position
        set_attitude(roll_angle=roll_output, pitch_angle=pitch_output, thrust=thrust_output)

        # Check if the target position is reached
        if abs(error_x) < 0.1 and abs(error_y) < 0.1 and abs(error_altitude) < 0.1:
            print("Target position stabilized!")
            break

        time.sleep(0.1)

def get_optical_flow_data():
    """
    Simulates getting data from an optical flow sensor.
    Replace this with actual sensor readings.
    """
    # Example: Simulated flow data, replace with actual sensor reading logic
    flow_x = 0.01  # Simulate small movement to the right
    flow_y = 0.02  # Simulate small forward movement
    return flow_x, flow_y

# Take off to 2 meters using barometer
arm_and_takeoff_nogps(2)

# Stabilize drone at a specific position
stabilize_position(target_x=0, target_y=0, target_altitude=2)

# Land the drone
print("Setting LAND mode...")
vehicle.mode = VehicleMode("LAND")
time.sleep(1)

# Close vehicle object before exiting script
print("Close vehicle object")
vehicle.close()

print("Completed")